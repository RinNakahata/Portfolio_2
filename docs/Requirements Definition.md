# 要件定義書

## 1. 機能概要

### 1.1. プロダクトコンセプト
未経験からITエンジニアを目指すユーザーをターゲットとし、職務経歴書（PDF/Word）をアップロードするだけで、AIがスキルや経験を自動で解析・可視化する。さらに、その解析結果を基に、ユーザーに最適な求人情報を意味的な類似度でマッチングし、推薦するWebアプリケーション。

### 1.2. ターゲットユーザー
未経験からITエンジニアへの転職を目指す求職者。

### 1.3. 主な機能フロー
1.  ユーザーが職務経歴書ファイルをアップロードする。
2.  バックエンドでファイル内容をテキスト化し、AIが内容を解析（スキル抽出、経験年数推定）。
3.  フロントエンドで解析結果をダッシュボードとして可視化する。
4.  AIがユーザーの職務経歴とシステム内の求人情報をベクトル化し、類似度の高い求人を推薦リストとして表示する。

## 2. 技術要件

| 領域 | 技術選定 | 目的・理由 |
| :--- | :--- | :--- |
| フロントエンド | `Next.js` (React), `TypeScript`, `Tailwind CSS` | モダンなUI/UXと型安全性の実現。採用企業の技術スタックへの適合。 |
| バックエンド | `Node.js`, `Express`, `TypeScript` | 軽量なAPIサーバーの構築。フロントエンドとの言語統一。採用企業の技術スタックへの適合。 |
| AI | `OpenAI API` (GPT-3.5/4, Embeddings) | コア機能である職務経歴書の解析、スキル抽出、及び求人とのベクトル類似度検索を実現するため。 |
| 認証 | `Auth0` | モダンでセキュアな認証機能の実装。採用企業の歓迎スキルに合致。 |
| インフラ/デプロイ | - **Front:** `Vercel`<br>- **Back:** `AWS Fargate` (Dockerコンテナ) | 分離されたフロント/バックのデプロイ経験と、コンテナ技術の知見をアピールするため。 |
| ファイル処理 | `mammoth.js`, `pdf-parse` (または同等のライブラリ) | バックエンドで `.docx` 及び `.pdf` ファイルからテキストを抽出するため。 |

## 3. 実装すべき機能一覧

### MVP (Minimum Viable Product) スコープ

-   **[ ] ファイルアップロード機能**
    -   [ ] PDF (`.pdf`) ファイルのアップロードUI。
    -   [ ] Word (`.docx`) ファイルのアップロードUI。
    -   [ ] ドラッグ＆ドロップによるアップロードインターフェース。
-   **[ ] バックエンドAPI**
    -   [ ] ファイルを受け取り、テキストを抽出するエンドポイント。
    -   [ ] 抽出したテキストを `OpenAI API` に渡し、スキルと経験年数を解析させるエンドポイント。
    -   [ ] 求人情報と類似度の高い求人リストを返すエンドポイント。
-   **[ ] キャリアサマリー表示機能**
    -   [ ] AIの解析処理中に、ローディングアニメーションやプログレスバーを表示。
    -   [ ] 解析されたスキルセットをタグ形式で表示。
    -   [ ] スキルごとの推定経験年数を表示。
-   **[ ] 求人推薦表示機能**
    -   [ ] マッチングした求人を類似度の高い順にリスト表示。
    -   [ ] 各求人項目には、会社名、役職、主要スキル、マッチ度（%など）を表示。
    -   [ ] 求人項目クリックで、詳細情報（職務内容、応募資格など）をモーダルで表示。

## 4. 制約事項

-   **データ永続化**: MVPでは、ユーザー情報、アップロードされたファイル、及びAIの解析結果はデータベースに保存せず、セッション中（ブラウザをリロードするまで）のみ保持する。
-   **ファイル破棄**: アップロードされたファイルは、サーバーサイドでのテキスト抽出処理が完了した直後に、速やかにメモリまたは一時保存領域から破棄する。
-   **求人データ**: 求人情報は、あらかじめ開発者が用意した10〜20件程度のダミーデータ（JSON形式）をシステムに内蔵して使用する。外部からの動的な取得は行わない。
-   **エラーハンドリング**: `OpenAI API` の呼び出し失敗時や、サポート外のファイル形式がアップロードされた場合など、想定されるエラーに対する適切なエラーメッセージをユーザーに表示する。

## 5. React開発におけるベストプラクティス

このプロジェクトで遵守すべきReactのベストプラクティスを以下に定義します。コードの品質、保守性、拡張性を高めることを目的とします。

### 5.1. ディレクトリ構造
- **機能ベースの構成**: `src/features/` ディレクトリ配下に、認証(`auth`)、ファイルアップロード(`fileUpload`)、キャリアサマリー(`summaryDashboard`)のように関連するコンポーネント、フック、型定義をまとめます。
- **共有コンポーネント**: 複数の機能で再利用されるUI部品（ボタン、モーダル等）は `src/components/` に配置します。
- **共通ロジック**: 共通で使われるカスタムフックは `src/hooks/`、ユーティリティ関数は `src/utils/` に配置します。

### 5.2. コンポーネント設計
- **責務の分離**: コンポーネントは単一責任の原則に従い、可能な限り小さく保ちます。
- **ロジックの分離**: API通信や複雑な状態ロジックは、コンポーネントからカスタムフック (`use...`) として切り離し、UI（JSX）とロジックを分離します。
- **命名規則**: コンポーネント名は `PascalCase` で、その役割が明確にわかるように命名します。（例: `FileUploadForm.tsx`, `SkillTag.tsx`）
- **Propsの型定義**: `TypeScript` を活用し、コンポーネントが受け取るPropsには必ず型を定義します。

### 5.3. 状態管理
- **ローカルステート**: コンポーネント内で完結する状態は `useState` を使用します。
- **複雑なローカルステート**: 複数の状態が関連しあう複雑なロジックは `useReducer` を検討します。
- **グローバルステート**: アプリケーション全体で共有する必要がある状態（例: ユーザーの認証状態、AIの解析結果）は、`Context API` と `useReducer` を組み合わせて管理します。これにより、Propsのバケツリレーを回避します。

### 5.4. カスタムフック
- **ロジックの再利用**: 繰り返し利用されるロジックは積極的にカスタムフックとして抽出します。
  - 例: `useAuth` (認証状態の管理), `useAnalysisApi` (バックエンドAPIとの通信), `useFileUpload` (ファイル処理)
- **命名規則**: カスタムフックは必ず `use` から始まる名前を付けます。（例: `useToggle.ts`）

### 5.5. パフォーマンス最適化
- **再レンダリングの抑制**: `React.memo` を用いて、Propsが変更されない限りコンポーネントの再レンダリングを防ぎます。
- **計算/関数のメモ化**: `useMemo` を使って重い計算結果をメモ化し、`useCallback` を使って子コンポーネントに渡す関数をメモ化します。
- **コード分割**: `Next.js` の `next/dynamic` を利用して、初期表示に不要なコンポーネント（例: 求人詳細モーダル）を遅延ロードし、初期パフォーマンスを向上させます。

### 5.6. コード品質
- **Linter / Formatter**: `ESLint` と `Prettier` を導入し、コードスタイルを統一して潜在的なバグを未然に防ぎます。コミット時に自動でチェックが走るように設定します。
- **TypeScript**: `any` 型の使用は原則禁止とします。APIのレスポンスなど、外部から受け取るデータには必ず型定義ファイル (`.d.ts`) やインターフェースを作成します。
- **クリーンアップ**: `useEffect` 内でイベントリスナーの登録やタイマー設定を行った場合は、必ずクリーンアップ関数を返してメモリリークを防ぎます。